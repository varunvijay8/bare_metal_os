/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include <main.h>
#include "led.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


TCB_t taskTCBs[] = { 	{(uint32_t*) IDLE_STACK_START, 0, TASK_RUNNING_STATE, idle_task},
						{(uint32_t*) T1_STACK_START, 0, TASK_RUNNING_STATE, task1_handler},
						{(uint32_t*) T2_STACK_START, 0, TASK_RUNNING_STATE, task2_handler},
						{(uint32_t*) T3_STACK_START, 0, TASK_RUNNING_STATE, task3_handler},
						{(uint32_t*) T4_STACK_START, 0, TASK_RUNNING_STATE, task4_handler}};
//// PSP of tasks
//uint32_t* taskStackPointer[] = { 	(uint32_t*) T1_STACK_START,
//									(uint32_t*) T2_STACK_START,
//									(uint32_t*) T3_STACK_START,
//									(uint32_t*) T4_STACK_START, };

/**
 * Global ticks (heart beat)
 */
volatile uint32_t g_tick_count;

/**
 * Enables the systick timer with counter value in tick_hz
 *
 */
void init_systick_timer(uint32_t tick_hz) {

	uint32_t count = SYST_CLK/tick_hz;

	SYST_RVR &= ~(0x00FFFFFF);		// clear
	SYST_RVR |= (count-1);			// load reload value register with count-1

	SYST_CSR |= (SYST_CSR_CLKSRC_MASK | SYST_CSR_TICKINIT_MASK | SYST_CSR_ENABLE_MASK);	// enable and fire systick timer
}

uint8_t current_task = 1;

/**
 * Update current_task to next valid task (Round Robin)
 *
 */
void update_current_task(void) {
	int numberOfBlockedTasks = 0;

	// if all tasks other than idle task is blocked
	// we run idle task
	while(numberOfBlockedTasks < NUMBER_OF_TASKS-1) {
		current_task = (current_task + 1) % NUMBER_OF_TASKS;
		if(current_task == 0) {
			current_task = 1;	// skip idle task
								// we run idle task only when all others are blocked
		}

		if(taskTCBs[current_task].run_state == TASK_BLOCKED_STATE) {
			++numberOfBlockedTasks;
		}
		else {
			break;
		}
	}

	// if all tasks are blocked we run the idle task
	if(numberOfBlockedTasks == NUMBER_OF_TASKS-1) {
		current_task = 0;
	}

}

void idle_task(void) {
	while(1) {
		printf("In idle task.\n");
	}
}

void task1_handler(void) {

	while(1) {
		led_on(LED_GREEN);
		delay(DELAY_COUNT_1S);
		led_off(LED_GREEN);
		delay(DELAY_COUNT_1S);
	}
}

void task2_handler(void) {

	while(1) {
		led_on(LED_ORANGE);
		delay(DELAY_COUNT_500MS);
		led_off(LED_ORANGE);
		delay(DELAY_COUNT_500MS);
	}
}

void task3_handler(void) {

	while(1) {
		led_on(LED_RED);
		delay(DELAY_COUNT_250MS);
		led_off(LED_RED);
		delay(DELAY_COUNT_250MS);
	}
}

void task4_handler(void) {

	while(1) {
		led_on(LED_BLUE);
		delay(DELAY_COUNT_125MS);
		led_off(LED_BLUE);
		delay(DELAY_COUNT_125MS);
	}
}

//uint32_t* startAddressTask[] = { (uint32_t*) task1_handler,
//								 (uint32_t*) task2_handler,
//								 (uint32_t*) task3_handler,
//								 (uint32_t*) task4_handler };

/**
 * Update MSP with SCHED_STACK_START
 *
 * note: we are using naked function since we are switching to
 *       MSP, hence we don't want the epilogue to perform
 *       unstacking
 */
__attribute__ ((naked)) void init_scheduler_stack(uint32_t top_of_sched_stack) {

	// init MSP with R0 which contains top_of_sched_stack
	__asm volatile("MSR MSP, R0");

	// switch to MSP
	__asm volatile("MRS R1, CONTROL");
	__asm volatile("BIC R0, R1, #2");	// clear SPSEL
	__asm volatile("MSR CONTROL, R0");

	// return since there is no prologue
	__asm volatile("BX LR");
}

/**
 * Initialize stack of the tasks
 *
 */
void init_tasks_stack(void) {

	for(uint32_t task = 0; task < NUMBER_OF_TASKS; task++) {

		// set T-bit in xPSR
		--taskTCBs[task].task_psp;
		*taskTCBs[task].task_psp = INIT_xPSR_VALUE;

		// task address
		--taskTCBs[task].task_psp;
		*taskTCBs[task].task_psp = (uint32_t)taskTCBs[task].task_handler;// + INIT_T_BIT_IN_PC;

		// LR to return to thread mode with PSP
		--taskTCBs[task].task_psp;
		*taskTCBs[task].task_psp = INIT_LR_VALUE;

		// init R0-R12
		for(uint32_t gpr = 0; gpr < NUMBER_OF_GP_REG; gpr++) {
			--taskTCBs[task].task_psp;
			*taskTCBs[task].task_psp = 0;
		}

	}

}

/**
 * Enable processor faults
 *
 */
void enable_processor_faults(void) {

	// 1. enable all configurable exceptions
	//		usage, mem manage and bus fault
	SHCRS |= (USAGE_FLT_MASK | BUS_FLT_MASK | MEM_FLT_MASK);
	CCR |= DIV_BY_ZERO_MASK;	// Divide by zero

}

/**
 * Get PSP of current task
 */
uint32_t get_psp_value(void){
	return (uint32_t)taskTCBs[current_task].task_psp;
}

/**
 * Save PSP of current task
 *
 */
void save_psp_value(uint32_t task_psp) {
	taskTCBs[current_task].task_psp = (uint32_t*)task_psp;
}

/**
 * Switch MSP to PSP
 *
 */
__attribute__ ((naked)) void switch_sp_to_psp(void) {

	//1. init PSP with task 1 stack address
//	uint32_t task1_psp = (uint32_t)get_psp_value();
//	__asm volatile("MOV R0, %0"::"r"(task1_psp):);
	__asm volatile("PUSH {LR}");		// save LR before jumping to get_psp_value
	__asm volatile("BL get_psp_value");
	__asm volatile("MSR PSP, R0");		// RO will have the SP of task1 as return
	__asm volatile("POP {LR}");			// restore LR


	//2. change SP to PSP using control register
	__asm volatile("MRS R1, CONTROL");
	__asm volatile("ORR R1, R1, #0x2");
	__asm volatile("MSR CONTROL, R1");

	__asm volatile("BX LR");
}

int main(void)
{
	enable_processor_faults();

	led_init_all();

	init_scheduler_stack(SCHED_STACK_START);
	init_tasks_stack();

	g_tick_count = 0;	// init global tick count
	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();
	task1_handler();

    /* Loop forever */
	for(;;);
}

/**
 * Block current task tick_count(ms)
 */
void task_delay(uint32_t tick_count) {

	taskTCBs[current_task].block_count = g_tick_count + tick_count;
	taskTCBs[current_task].run_state = TASK_BLOCKED_STATE;
}

/**
 * SysTick handler
 *
 * note: implemented as naked
 */
__attribute__ ((naked)) void SysTick_Handler(void) {

	/**
	 * Increment global tick count every ms
	 */
	__asm volatile("ADD R0, %0, #1"::"r"(g_tick_count):);
	__asm volatile("MOV %0, R0":"=r"(g_tick_count)::);

	/**
	 * Save the context of current task
	 *
	 * 1. Get current task's PSP
	 * 2. Save SF2 using PSP (we cannot use push since we are in MSP)
	 * 	  Use STMDB (decrements before pushing which is similar to
	 * 	  stacking)
	 * 3. Save PSP to "taskTCBs[current_task].task_psp"
	 */
	__asm volatile("MRS R0, PSP");
	__asm volatile("STMDB R0!, {R4-R11}");
	__asm volatile("PUSH {LR}");			// was missing in initial implementation
											// which led to HardFault, we need to save
											// and restore exec_return value
	__asm volatile("BL save_psp_value");	// R0 has the updated SP value after
											// pushing SF2

	/**
	 * Retrieve the context of next task
	 *
	 * 1. Decide next task to run
	 * 2. Get saved PSP of next task
	 * 3. Restore SF2 using PSP
	 * 4. Update PSP and exit
	 */
	__asm volatile("BL update_current_task");
	__asm volatile("BL get_psp_value");
	__asm volatile("LDMIA R0!, {R4-R11}");		// R0 has SP of next task
	__asm volatile("MSR PSP, R0");

	// exit will automatically restore SF1
	__asm volatile("POP {LR}");
	__asm volatile("BX LR");
}

void HardFault_Handler(void) {
	printf("HardFault_Handler. \n");

	/* Loop forever */
	for(;;);
}

void MemManage_Handler(void) {
	printf("MemManage_Handler. \n");

	/* Loop forever */
	for(;;);
}

void BusFault_Handler(void) {
	printf("BusFault_Handler. \n");

	/* Loop forever */
	for(;;);
}
